受到数字电路的启发想到了这个方法，大概看了一下没人写过，把它放了上来。

列出0-8的二进制数:
0    0
1    1
2   10
3   11
4  100
5  101
6  110
7  111
8 1000

观察可以发现一个规律，例如3和7，7比3大4，体现在二进制中，111就是在11的首位添上1。自然1的个数也要加一

那这个规律就是，任何一个大于等于1的数字n，它的二进制数中**一的个数**实际就是**之前某个数n-k**的一的个数+1。
k很显然就是不大于n的2的整数次幂中的最大值。
在进行遍历的时候只需要额外维护一个k值，每当n>=k，k更新为k*2

代码如下。

* 

```
class Solution:
    def countBits(self, num: int) -> List[int]:
        dp = [0]*(num+1)
        k = 1
        for i in range(1,num+1):
            if i >= k*2 :
                k = k*2
            dp[i] = dp[i-k]+1
        
        return dp
```

